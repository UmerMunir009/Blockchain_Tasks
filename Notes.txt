Phase 1: The Token & Foundation (The "Betting Slips")
Before you can trade, you need the actual assets. In a binary market, "shares" are represented by ERC-20 tokens.
    Objective: Create the OutcomeToken contract and the main PredictionMarket engine.
    Key Tasks:
        Standard ERC-20: Deploy two separate ERC-20 tokens: YES and NO.
The Collateral Logic: Define the fixed value. In your case, 1 Winning Token=0.01 ETH.
        Minting Strategy: When a user provides 0.01 ETH to the market, the contract mints 1 YES and 1 NO token. This ensures the market is always fully collateralized (0.01 ETH×1=0.01 ETH).

Phase 2: The AMM Engine (The "Liquidity Pool")
This is the "brain" of your market. Since you aren't waiting for another person to take the other side of your bet, you trade against a pool of tokens.
    Objective: Implement the math that determines the price of YES and NO tokens based on supply and demand.
Key Concept: The Pricing Curve.
    As more people buy YES, the pool's supply of YES decreases, making the price go up.
Price Calculation: Use a simplified version of the Constant Product formula: x⋅y=k.
    Key Functions:
        buyOutcome(tokenType, amount): Takes ETH, calculates the price based on current reserves, and gives the user tokens.
        sellOutcome(tokenType, amount): Takes tokens back from the user and returns ETH based on the current market price.

Phase 3: The Oracle & Resolution (The "Judge")
A prediction market is useless if it doesn't know who won the race. You need a trusted way to feed the race result into the blockchain.
    Objective: Define how the "Green Car" victory is verified.
    Key Tasks:
        Oracle Role: Create a resolveMarket(bool greenCarWon) function restricted to a specific oracle address (you).
        Locking the Market: Once the oracle reports, trading must be disabled immediately to prevent "cheating" after the result is known.
        Winning Token Assignment: If Green wins, the YES token is marked as the "Winner."

Phase 4: Redemption & Payouts (The "Payday")
The final stage where winners get their ETH and losers walk away with nothing.
    Objective: Allow users to swap their winning tokens for the 0.01 ETH collateral.
    Key Tasks:
        Claim Function: Users call claimPayout(amount).
        The Math: If YES won, the contract checks the user's YES balance and sends balance * 0.01 ETH.
        Burning: The tokens are "burned" (destroyed) upon redemption to prevent double-claiming.

Phase,Component,Logic,Goal
1,Collateral,1 Set (Y+N)=0.01 ETH,Ensure 100% solvency.
2,AMM,x⋅y=k,"Automated, instant trading."
3,Oracle,onlyOwner / Data Feed,Verify the real-world race.
4,Redeem,payout = shares * 0.01,Distribute rewards to winners.

Metric,Traditional Betting,Our AMM Market
Liquidity,"Provided by ""House""",Provided by LPs/Pools
Flexibility,Locked until end,Sell anytime
Transparency,Hidden margins,Open-source code
Price,Set by Bookie,Set by Math (x⋅y=k)   